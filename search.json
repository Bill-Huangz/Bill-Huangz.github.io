[{"title":"Luogu-P1799 數列","url":"/2021/06/30/LuoguP1799/","content":"洛谷P1799 數列題目連結: https://www.luogu.com.cn/problem/P1799題目大意:給定一個數列 $A_n$，你現在可以做下列操作任意次數(也可 $0$ 次):\n\n從這個數列刪除一個元素，剩下的元素依照相對位置不變靠攏。\n\n令新的數列為 $B_k$，請問$B_i=i$的位置最多能有多少個。\n$n\\leq 1000$$A_i\\leq 10^9$\nSample$Sample$ $Input$\n51 1 2 5 4\n$Sample$ $Output$\n3\n刪除掉原數列的其中一個 $1$，使數列變成$1,2,5,4$，其中 $1,2,4$ 符合 $B_i=i$。\nSolution考慮 $Dynamic$ $programming$。令 $dp[i][j]$ 為前 $i$ 個數字刪除 $j$ 個數後，$B_i=i$ 的最多個數。\n轉移式如下:\n\n如果要刪除第 $i$ 個數，則 $dp[i][j]={max(dp[k][j-1])| 1\\leq k&lt;i }$\n如果不刪除第 $i$ 個數，則 $dp[i][j]={max(dp[k][j]+[A_{i}=(i-j)]| 1\\leq k&lt;i }$\n\n所以 $dp[i][j]$ 即為上面兩種中的最大值。所求就是 ${max(dp[n][i])| 1\\leq i\\leq n }$\nCode#include &lt;bits/stdc++.h&gt;#define int long long#define SpeedUP ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);using namespace std;int n;int a[1005];int dp[1005][1005]; //dp[i][j]表第1~i個數已經有j個數刪除void sol()&#123;    cin &gt;&gt;n;    for (int i=1;i&lt;=n;i++) cin &gt;&gt;a[i];    dp[1][0]=(a[1]==1);dp[1][1]=0;    for (int i=2;i&lt;=n;i++)&#123;        for (int j=0;j&lt;=i;j++)&#123;            int mx1=0,mx2=0;            for (int k=j;k&lt;i;k++) mx1=max(mx1,dp[k][j]);            for (int k=j;k&lt;i;k++) mx2=max(mx2,dp[k][j-1]);            dp[i][j]=max(mx1+(a[i]==(i-j)),mx2);        &#125;    &#125;    int ans=0;    for (int i=1;i&lt;=n;i++) ans=max(ans,dp[n][i]);    cout &lt;&lt;ans;&#125;signed main()&#123;    SpeedUP    int tEst=1;    //cin &gt;&gt;tEst;    while (tEst--) sol();    return 0;&#125;\n時間複雜度: $O(n^3)$。看起來會吞 $TLE$，可是卻能 $AC$ ???原因很簡單，因為在洛谷的評測業面有一個神奇小勾勾。\n神奇小勾勾勾下去後，就能加速 $AC$ 了~~\nSolution-2但不是每個網站都有神奇小勾勾，是說可以砸一個資料結構讓複雜度變 $O(n^2logn)$。但我懶的寫 $0u0$。這邊說一個 $O(n^2)$ 的算法。其實就是上面的方法拔掉最後一個迴圈…\nCode-2#include &lt;bits/stdc++.h&gt;#define int long long#define SpeedUP ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);using namespace std;int n;int a[1005];int dp[1005][1005]; //dp[i][j]表第1~i個數已經有j個數刪除void sol()&#123;    cin &gt;&gt;n;    for (int i=1;i&lt;=n;i++) &#123;        cin &gt;&gt;a[i];        assert(a[i]&lt;=1000000000);    &#125;    dp[1][0]=(a[1]==1);dp[1][1]=0;    for (int i=2;i&lt;=n;i++)&#123;        for (int j=0;j&lt;=i;j++)&#123;            dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+(a[i]==(i-j)));        &#125;    &#125;    int ans=0;    for (int i=1;i&lt;=n;i++) ans=max(ans,dp[n][i]);    cout &lt;&lt;ans;&#125;signed main()&#123;    SpeedUP    int tEst=1;    //cin &gt;&gt;tEst;    while (tEst--) sol();    return 0;&#125;\n時間複雜度: $O(n^2)$。其實狀態轉移 $dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+[A_i=i-j])$ 就好…我弱，只會 $O(n^3)$+小勾勾…，Dp要再練了…\n","categories":[],"tags":["algorithm","C++","Luogu"]},{"title":"Codeforce 1539D-PriceFixed","url":"/2021/06/22/1539D/","content":"Codeforce 1539D-PriceFixed題目連結: https://codeforces.com/problemset/problem/1539/D題目大意:一間商店裡，有$n$種商品，Lena 想買各$a_i$個，一次買一個，每個商品都是$2$元。如果你在買第$i$種商品之前已經買了$b_i$個商品，那麼該商品只需花費$1$元。請問: Lena最少需花多少錢才能買齊。\nSample$Sample$ $Input$\n33 41 31 5\n$Sample$ $Output$ \n8\n\n$Sample$ $Input$\n52 72 81 22 41 8\n$Sample$ $Output$ \n12\nSolution考慮兩種商品 $X,Y$，且有$b_X&lt;b_Y$，如果我們想要買到優惠，顯然我們比較容易達到 $X$ 的量(即 $b_X$ )，所以我們可以將每種商品 $i$ 先依 $b_i$ 排序，接著利用雙指針，假設現在已經買了 $tot$ 個商品，而商品 $i$ 需要 $b_i-tot$ 個才能有優惠，那麼我們就從後面買 $b_i-tot$個商品，重複執行直到全部買完。\nCode#include &lt;bits/stdc++.h&gt;#define int long long#define pi pair&lt;int, int&gt;#define fi first#define se second#define SpeedUP ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);using namespace std;int n;pi a[100005];// first 表 要買的個數(a) second 表 優惠需求的量(b)void sol()&#123;    cin &gt;&gt;n;    for (int i=0;i&lt;n;i++) cin &gt;&gt;a[i].fi&gt;&gt;a[i].se;    sort(a,a+n,[](pi lh,pi rh)&#123;        return lh.se&lt;rh.se; // 依照 b_i 排序    &#125;);    int r=n-1,tot=0,ans=0;    for (int i=0;i&lt;n;i++)&#123;        if (i==r) break; // 當 i=r 時，直接跳出 之後處理        if (tot&gt;=a[i].se)&#123;            ans+=a[i].fi;            tot+=a[i].fi;            a[i].fi=0;        &#125;        else&#123;            while (r&gt;i&amp;&amp;a[i].se-tot-a[r].fi&gt;=0)&#123;                tot+=a[r].fi;                ans+=2*a[r].fi;                r--;            &#125;            if (i==r) break;            int k=a[i].se-tot;            ans+=2*k;            a[r].fi-=k;            tot+=k;            ans+=a[i].fi;            tot+=a[i].fi;        &#125;    &#125;    // 處理 i==r 時    if (tot&gt;=a[r].se) &#123;        cout &lt;&lt;ans+a[r].fi;    &#125;    else if (tot&lt;a[r].se&amp;&amp;tot+a[r].fi&gt;=a[r].se)&#123;        cout &lt;&lt;ans+(a[r].se-tot)*2+(a[r].fi-(a[r].se-tot));    &#125;    else&#123;        cout &lt;&lt;ans+a[r].fi*2;    &#125;&#125;signed main()&#123;    SpeedUP     int tEst=1;    //cin &gt;&gt;tEst;    while (tEst--) sol();   return 0;&#125;\n時間複雜度: $O(nlogn+n)$，排序+計算。這題想法不難，可是我實作太弱qwq，卡了很久才找到bug，AC code也很醜。\n","categories":[],"tags":["CF","algorithm","C++"]},{"title":"Which number is larger?","url":"/2021/06/12/50v-s-99/","content":"Which is larger? $50^{99}$ or $99!$滑youtube的時候，神秘的演算法推薦了我這部影片(從此我的首頁就被數學佔領了)，這篇內容主要就是比較 $50^{99}$ 跟 $99!$ 的大小，以及證明 $for$ $n \\geq 2$ , $\\left({n+1}\\over{2}\\right)^n$ $&gt;$ $n!$ \nSIMPLE原題目是求 $50^{99}$ 跟 $99!$ 比較大，那麼我們就直接對這兩個數進行操作。考慮 $R=$ $\\frac{ 50^{99} }{99!}$ ，可知 :\n\nif $R&gt;1$ $\\Rightarrow$ $50^{99} &gt; 99!$\nif $R&lt;1$ $\\Rightarrow$ $50^{99} &lt; 99!$\n\n接著把 $R$ 展開:$$ R= \\frac{50\\times50\\times50\\times…\\times\\times50\\times50\\times50}{99\\times98\\times97\\times…\\times3\\times2\\times1}$$分母交換位置:\n$$ R= \\frac{50\\times50}{99\\times1}\\times\\frac{50\\times50}{98\\times2}\\times…\\times\\frac{50\\times50}{51\\times49}\\times\\frac{50}{50}$$\n$\\because$ 分母的部分相加皆為 $100=(50+k)+(50-k)$ ,又 $(50+k)(50-k)=50^2 - k^2\\leq50^2$$\\therefore$ 分子的部分皆大於分母$\\therefore$ $R&gt;1$$\\therefore$ $50^{99}&gt;99!$\nGENERAL下面將利用數學歸納法證明$for$ $n \\geq 2$ , $\\left({n+1}\\over{2}\\right)^n$ $&gt;$ $n!$ 成立。\nStep 1將 $n=2$ 帶入 $\\left({2+1}\\over{2}\\right)^2$ $= \\frac{9}{4}$ $&gt;$ $2!=2$。$\\therefore$ 當 $n=2$ 時，命題成立。\nStep 2Claim 當 $n=k$ 時，命題 ${(k+1)^k}\\over{2}$ $&gt;$ $k!$ 成立。\nStep 3考慮 $n=k+1$$suppose$ $\\left({(k+1)+1}\\over{2}\\right)^{k+1} &gt; (k+1)!$\n$\\left({(k+1)+1}\\over{2}\\right)^{k+1}$= $\\frac{(k+1)^{k+1} +C{k+1\\choose1}(k+1)^k+ X }{2\\times2^k}$ &gt; $\\frac{(k+1)^{k+1}+{(k+1)(k+1)^k}}{2\\times 2^k}=\\frac{(k+1)^{k+1}}{2^k}=(k+1)\\frac{(k+1)^k}{2^k}$$\\because \\frac{(k+1)^k}{2}$ $&gt;$ $k!$$\\therefore (k+1)\\frac{(k+1)^k}{2^k} &gt; (k+1)\\times k!=(k+1)!$$\\therefore \\left({(k+1)+1}\\over{2}\\right)^{k+1} &gt; (k+1)!$($X$ 是分子展開後的剩下部分，$X&gt;0$)因此藉由數學歸納法，我們證明了 $for$ $n \\geq 2$ , $\\left({n+1}\\over{2}\\right)^n$ $&gt;$ $n!$ 成立。把 $n=99$ 帶入，即可得到 $50^{99} &gt; 99!$ 。\nWe are the 21st century# I love Python,Python number one import math  print (pow(50,99)&gt;math.factorial(99));\nTrue","categories":[],"tags":["math","proof"]},{"title":"Codeforce 1536A-Omkar and Bad Story","url":"/2021/06/09/post/","content":"Codeforce 1536A-Omkar and Bad Story題目連結:https://codeforces.com/problemset/problem/1536/A題目大意:給定一個有$n$個元素的數列 &lt;$A$&gt;，求構造出一個數列 &lt;$B$&gt; 使得:(1) $B$ 的 $size\\leq300$(2) $A$ 裡的元素至少都要在 $B$ 出現一次(3) 對於所有的 $b_i,b_j$ ， $|b_i-b_j|$至少在 $B$ 出現一次$-100 \\leq A_i\\leq100$\nSolution如果 $A$ 裡面的某個元素為負數，那麼我們絕對不可能構造出數列&lt;$B$&gt;，因為加絕對值後的數必為非負整數。確定了&lt;$A$&gt;的元素都為非負整數後，那麼接著輸出 $0$ ~ $100$ 就好了，理由如下:(1) 因為 $A$ 的最大可能值為 $100$，故 $0$ ~ $100$ 必可以包含 $A$ 的元素至少一次(2) 假設 $b_i&lt;b_j$ ，那麼 $b_i\\leq |b_i-b_j|\\leq b_j$，而 $A$ 的最大值為 $100$ ，最小值為 $0$，所以 $B=[0,1,2,…,100]$必定可以包含所有的$|b_i-b_j|$\nCode#include &lt;bits/stdc++.h&gt;#define int long long#define menhera_chan_is_mine ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define pb push_back#define pi pair&lt;int, int&gt;#define BE(i) i.begin(),i.end()#define fi first#define se second#define INF 2147483647#define mkp make_pair#define ist insert#define mod 1000000009//#pragma GCC optimize(&quot;Ofast,unroll-loops,no-stack-protector,fast-math&quot;)//#pragma GCC optimize(&quot;O2&quot;)using namespace std;int min(int a, int b)&#123;return a &lt; b ? a : b;&#125;int max(int a, int b)&#123;return a &gt; b ? a : b;&#125;bool isprime(int k)&#123;bool is=1 ; for ( int i = 2 ; i*i &lt;= k ; i++ ) if ( k % i == 0 ) is = 0 ; return k&gt;1?is:0;&#125;const double PI=acos(-1);int n;int a[105];inline void sol()&#123;    cin &gt;&gt;n;    for (int i=0;i&lt;n;i++) cin &gt;&gt;a[i];    bool flg=0;    for (int i=0;i&lt;n;i++)&#123;        if (a[i]&lt;0) flg=1;    &#125;    if (flg) cout &lt;&lt;&quot;NO\\n&quot;;    else &#123;        cout &lt;&lt;&quot;YES\\n101\\n&quot;;        for (int i=0;i&lt;=100;i++)            cout &lt;&lt;i&lt;&lt;&quot; &quot;;        cout &lt;&lt;&quot;\\n&quot;;    &#125;&#125;signed main()&#123;    menhera_chan_is_mine    int _=1;    cin &gt;&gt;_;    while (_--) sol();    return 0;&#125;\n時間複雜度:$O(n)$\n","categories":[],"tags":["CF","algorithm","C++"]}]