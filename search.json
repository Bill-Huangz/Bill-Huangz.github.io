[{"title":"TRML思考賽-1","url":"/2021/08/23/TRML%E6%80%9D%E8%80%83%E8%B3%BD-1/","content":"2021 TRML 思考賽 第一題組題目:從一個 $n\\times n$ 的方格紙的左下角，沿著格線依最短路徑走到右上角。定義 $N(n,k)$ 表示為在行徑過程中轉彎了 $k$ 次的方法數。例如:當 $n=2$，$k=1$時，$N(2,1)=2$ 如 (圖1)當 $n=2$，$k=2$時，$N(2,2)=2$ 如 (圖2)當 $n=2$，$k=3$時，$N(2,3)=2$ 如 (圖3)中間可以暴力窮舉的題目這邊不多說明，直接講推一般式的(5)(6)\n(5)試求當 $k$ 為偶數時，$N(n,k)$的一般式(以 $n$ 與 $k$ 表示)注意 這裡的 $k$ 為偶數，在這裡偶數很重要\n因為是走最短路徑，所以水平方向的總路徑長與垂直方向的總路徑長皆為 $n$。而每轉一次彎，行徑方向都會改變一次(以下以 $H$ 表示水平方向、$V$ 表示鉛直方向)所以會形成 $ H1,V_1,H_2,V_2,…,V{\\frac{k}{2}-1},H{\\frac{k}{2}},V{\\frac{k}{2}},H_{\\frac{k}{2}+1} $ 的序列。其中 $ H_i,1\\leq i\\leq \\frac{k}{2}+1$ 與 $V_j,1\\leq j\\leq \\frac{k}{2} $ 分別代表每個水平線段與鉛直線段的長度。因此可以列出兩條式子:\n\n\\begin{cases} H_1+H_2+H_3+...+H_{\\frac{k}{2}}+H_{\\frac{k}{2}+1}=n\\\\\n V_1+V_2+V_3+...+V_{\\frac{k}{2}-1}+V_{\\frac{k}{2}}=n\n\\end{cases}令 $H_i’$、$V_j’$ 使得 $H_i=H_i’+1$，$V_j’=V_j+1$，則式子可改寫成如下:\n\n\\begin{cases} H_1'+H_2'+H_3'+...+H_{\\frac{k}{2}}'+H_{\\frac{k}{2}+1}'=n-(\\frac{k}{2}+1)\\\\\n V_1'+V_2'+V_3'+...+V_{\\frac{k}{2}-1}'+V_{\\frac{k}{2}}'=n-\\frac{k}{2}\n\\end{cases}熟悉重複組合(combination with repetition)的人，應該很熟悉這種題目。可以秒解出水平線段的組合方法有 $C{n-1 \\choose \\frac{k}{2}}$種，鉛直方向有 $C{n-1 \\choose \\frac{k}{2}-1}$種。所以當 $k$ 為偶數時 $N(n,k)=C{n-1 \\choose \\frac{k}{2}}\\times C{n-1 \\choose \\frac{k}{2}-1}\\times 2$。$\\times 2$的原因是因為一開始可選擇水平或鉛直2種情況。\n不熟悉重複組合的人去學重複組合，換個方向思考一下。嘗試看看這道題目:滿足 $x+y+z+w=6$的非負整數解有幾組?素養化一下題目敘述:現有4個編號分別為 $x,y,z,w$ 的桶子以及6顆相同的球，請問將這6顆球放進這4個桶子的方法數有幾種?考慮有3根相同的隔板，劃分出4個空間，每個空間分別代表一個桶子，而該空間內球的數量就是桶子內球的數量。所以總方法數就是將3根相同的棍子以及6顆相同的球的排列分法數。所以答案為 $\\frac{(6+3)!}{6!3!}=C{9 \\choose 3}=84$。\n回到思考賽的題目，因為 $H_i$ 必須要大於 $0$。所以我們將 $H_i$ 變成 $H_i’+1$後，變向成去解了 $H_i’$ 的非負整數解。對 $V_j$ 同理。接著就按照上面的想法就好啦。\n對於 $H_i$，考慮有 $\\frac{k}{2}$個隔板，$n-(\\frac{k}{2}+1)$顆球。\n所以方法數為 $\\frac{(n-(\\frac{k}{2}+1)+\\frac{k}{2})!}{(n-(\\frac{k}{2}+1))!\\frac{k}{2}!}=\\frac{(n-1)!}{(n-(\\frac{k}{2}+1))!\\frac{k}{2}!}=C{(n-1) \\choose \\frac{k}{2}}$\n對於 $V_j$，考慮有 $\\frac{k}{2}-1$個隔板，$n-\\frac{k}{2}$顆球。\n所以方法數為 $\\frac{(n-\\frac{k}{2}+\\frac{k}{2}-1)!}{(n-\\frac{k}{2})!(\\frac{k}{2}-1)!}=\\frac{(n-1)!}{(n-\\frac{k}{2})!(\\frac{k}{2}-1)!}=C{(n-1) \\choose \\frac{k}{2}-1}$\n所以 $N(n,k)=C{n-1 \\choose \\frac{k}{2}}\\times C{n-1 \\choose \\frac{k}{2}-1}\\times 2$。$\\times 2$的原因一樣是因為一開始可選擇水平或鉛直2種情況。\n(6)試求當 $k$ 為奇數時，$N(n,k)$的一般式(以 $n$ 與 $k$ 表示)注意 這裡的 $k$ 為奇數，在這裡奇數很重要可是偶數比較難\n這題就比較簡單了，因為 $k$ 為奇數，所以你的序列會長成這樣:$H1,V_1,H_2,V_2,…,H{\\frac{k-1}{2}},V{\\frac{k-1}{2}},H{\\frac{k+1}{2}},V_{\\frac{k+1}{2}}$\n可列出式子:\n\n\\begin{cases} H_1+H_2+H_3+...+H_{\\frac{k-1}{2}}+H_{\\frac{k+1}{2}}=n\\\\\n V_1+V_2+V_3+...+V_{\\frac{k-1}{2}}+V_{\\frac{k+1}{2}}=n\n\\end{cases}一樣令 $H_i’$、$V_j’$ 使得 $H_i=H_i’+1$，$V_j’=V_j+1$，改寫式子如下:\n\n\\begin{cases} H_1'+H_2'+H_3'+...+H_{\\frac{k-1}{2}}'+H_{\\frac{k+1}{2}}'=n-\\frac{k+1}{2}\\\\\n V_1'+V_2'+V_3'+...+V_{\\frac{k-1}{2}}'+V_{\\frac{k+1}{2}}'=n-\\frac{k+1}{2}\n\\end{cases}所以當 $k$ 為奇數時 $N(n,k)=C{ n-1 \\choose \\frac{k-1}{2}}^2 \\times 2$$\\times 2$一樣是因為一開始可選擇水平或鉛直2種情況。最後提醒: 當 $k\\geq2n$ 時，$N(n,k)=0$喔\n","categories":[],"tags":["TRML"]},{"title":"Luogu-P1799 數列","url":"/2021/06/30/LuoguP1799/","content":" 洛谷P1799 數列題目連結: https://www.luogu.com.cn/problem/P1799題目大意:給定一個數列 $A_n$，你現在可以做下列操作任意次數(也可 $0$ 次):\n\n從這個數列刪除一個元素，剩下的元素依照相對位置不變靠攏。\n\n令新的數列為 $B_k$，請問$B_i=i$的位置最多能有多少個。\n$n\\leq 1000$$A_i\\leq 10^9$\nSample$Sample$ $Input$51 1 2 5 4$Sample$ $Output$3刪除掉原數列的其中一個 $1$，使數列變成$1,2,5,4$，其中 $1,2,4$ 符合 $B_i=i$。\nSolution考慮 $Dynamic$ $programming$。令 $dp[i][j]$ 為前 $i$ 個數字刪除 $j$ 個數後，$B_i=i$ 的最多個數。\n轉移式如下:\n\n如果要刪除第 $i$ 個數，則 $dp[i][j]={max(dp[k][j-1])| 1\\leq k&lt;i }$\n如果不刪除第 $i$ 個數，則 $dp[i][j]={max(dp[k][j]+[A_{i}=(i-j)]| 1\\leq k&lt;i }$\n\n所以 $dp[i][j]$ 即為上面兩種中的最大值。所求就是 ${max(dp[n][i])| 1\\leq i\\leq n }$\nCode#include &lt;bits/stdc++.h&gt;#define int long long#define SpeedUP ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);using namespace std;int n;int a[1005];int dp[1005][1005]; //dp[i][j]表第1~i個數已經有j個數刪除void sol()&#123;    cin &gt;&gt;n;    for (int i=1;i&lt;=n;i++) cin &gt;&gt;a[i];    dp[1][0]=(a[1]==1);dp[1][1]=0;    for (int i=2;i&lt;=n;i++)&#123;        for (int j=0;j&lt;=i;j++)&#123;            int mx1=0,mx2=0;            for (int k=j;k&lt;i;k++) mx1=max(mx1,dp[k][j]);            for (int k=j;k&lt;i;k++) mx2=max(mx2,dp[k][j-1]);            dp[i][j]=max(mx1+(a[i]==(i-j)),mx2);        &#125;    &#125;    int ans=0;    for (int i=1;i&lt;=n;i++) ans=max(ans,dp[n][i]);    cout &lt;&lt;ans;&#125;signed main()&#123;    SpeedUP    int tEst=1;    //cin &gt;&gt;tEst;    while (tEst--) sol();    return 0;&#125;\n時間複雜度: $O(n^3)$。看起來會吞 $TLE$，可是卻能 $AC$ ???原因很簡單，因為在洛谷的評測業面有一個神奇小勾勾。\n神奇小勾勾勾下去後，就能加速 $AC$ 了~~\nSolution-2但不是每個網站都有神奇小勾勾，是說可以砸一個資料結構讓複雜度變 $O(n^2logn)$。但我懶的寫 $0u0$。這邊說一個 $O(n^2)$ 的算法。其實就是上面的方法拔掉最後一個迴圈…\nCode-2#include &lt;bits/stdc++.h&gt;#define int long long#define SpeedUP ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);using namespace std;int n;int a[1005];int dp[1005][1005]; //dp[i][j]表第1~i個數已經有j個數刪除void sol()&#123;    cin &gt;&gt;n;    for (int i=1;i&lt;=n;i++) &#123;        cin &gt;&gt;a[i];        assert(a[i]&lt;=1000000000);    &#125;    dp[1][0]=(a[1]==1);dp[1][1]=0;    for (int i=2;i&lt;=n;i++)&#123;        for (int j=0;j&lt;=i;j++)&#123;            dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+(a[i]==(i-j)));        &#125;    &#125;    int ans=0;    for (int i=1;i&lt;=n;i++) ans=max(ans,dp[n][i]);    cout &lt;&lt;ans;&#125;signed main()&#123;    SpeedUP    int tEst=1;    //cin &gt;&gt;tEst;    while (tEst--) sol();    return 0;&#125;\n時間複雜度: $O(n^2)$。其實狀態轉移 $dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+[A_i=i-j])$ 就好…我弱，只會 $O(n^3)$+小勾勾…，Dp要再練了…\n","categories":[],"tags":["algorithm","C++","Luogu"]},{"title":"Codeforce 1539D-PriceFixed","url":"/2021/06/22/1539D/","content":"Codeforce 1539D-PriceFixed題目連結: https://codeforces.com/problemset/problem/1539/D題目大意:一間商店裡，有$n$種商品，Lena 想買各$a_i$個，一次買一個，每個商品都是$2$元。如果你在買第$i$種商品之前已經買了$b_i$個商品，那麼該商品只需花費$1$元。請問: Lena最少需花多少錢才能買齊。\nSample$Sample$ $Input$33 41 31 5$Sample$ $Output$ \n8$Sample$ $Input$52 72 81 22 41 8$Sample$ $Output$12\nSolution考慮兩種商品 $X,Y$，且有$b_X&lt;b_Y$，如果我們想要買到優惠，顯然我們比較容易達到 $X$ 的量(即 $b_X$ )，所以我們可以將每種商品 $i$ 先依 $b_i$ 排序，接著利用雙指針，假設現在已經買了 $tot$ 個商品，而商品 $i$ 需要 $b_i-tot$ 個才能有優惠，那麼我們就從後面買 $b_i-tot$個商品，重複執行直到全部買完。\nCode#include &lt;bits/stdc++.h&gt;#define int long long#define pi pair&lt;int, int&gt;#define fi first#define se second#define SpeedUP ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);using namespace std;int n;pi a[100005];// first 表 要買的個數(a) second 表 優惠需求的量(b)void sol()&#123;    cin &gt;&gt;n;    for (int i=0;i&lt;n;i++) cin &gt;&gt;a[i].fi&gt;&gt;a[i].se;    sort(a,a+n,[](pi lh,pi rh)&#123;        return lh.se&lt;rh.se; // 依照 b_i 排序    &#125;);    int r=n-1,tot=0,ans=0;    for (int i=0;i&lt;n;i++)&#123;        if (i==r) break; // 當 i=r 時，直接跳出 之後處理        if (tot&gt;=a[i].se)&#123;            ans+=a[i].fi;            tot+=a[i].fi;            a[i].fi=0;        &#125;        else&#123;            while (r&gt;i&amp;&amp;a[i].se-tot-a[r].fi&gt;=0)&#123;                tot+=a[r].fi;                ans+=2*a[r].fi;                r--;            &#125;            if (i==r) break;            int k=a[i].se-tot;            ans+=2*k;            a[r].fi-=k;            tot+=k;            ans+=a[i].fi;            tot+=a[i].fi;        &#125;    &#125;    // 處理 i==r 時    if (tot&gt;=a[r].se) &#123;        cout &lt;&lt;ans+a[r].fi;    &#125;    else if (tot&lt;a[r].se&amp;&amp;tot+a[r].fi&gt;=a[r].se)&#123;        cout &lt;&lt;ans+(a[r].se-tot)*2+(a[r].fi-(a[r].se-tot));    &#125;    else&#123;        cout &lt;&lt;ans+a[r].fi*2;    &#125;&#125;signed main()&#123;    SpeedUP     int tEst=1;    //cin &gt;&gt;tEst;    while (tEst--) sol();   return 0;&#125;\n時間複雜度: $O(nlogn+n)$，排序+計算。這題想法不難，可是我實作太弱qwq，卡了很久才找到bug，AC code也很醜。\n","categories":[],"tags":["CF","algorithm","C++"]},{"title":"Which number is larger?","url":"/2021/06/12/50v-s-99/","content":"Which is larger? $50^{99}$ or $99!$滑youtube的時候，神秘的演算法推薦了我這部影片(從此我的首頁就被數學佔領了)，這篇內容主要就是比較 $50^{99}$ 跟 $99!$ 的大小，以及證明 $for$ $n \\geq 2$ , $\\left({n+1}\\over{2}\\right)^n$ $&gt;$ $n!$ \nSIMPLE原題目是求 $50^{99}$ 跟 $99!$ 比較大，那麼我們就直接對這兩個數進行操作。考慮 $R=$ $\\frac{ 50^{99} }{99!}$ ，可知 :\n\nif $R&gt;1$ $\\Rightarrow$ $50^{99} &gt; 99!$\nif $R&lt;1$ $\\Rightarrow$ $50^{99} &lt; 99!$\n\n接著把 $R$ 展開:\nR= \\frac{50\\times50\\times50\\times...\\times\\times50\\times50\\times50}{99\\times98\\times97\\times...\\times3\\times2\\times1}分母交換位置:\nR= \\frac{50\\times50}{99\\times1}\\times\n\\frac{50\\times50}{98\\times2}\\times...\\times\n\\frac{50\\times50}{51\\times49}\\times\\frac{50}{50}$\\because$ 分母的部分相加皆為 $100=(50+k)+(50-k)$ ,又 $(50+k)(50-k)=50^2 - k^2\\leq50^2$$\\therefore$ 分子的部分皆大於分母$\\therefore$ $R&gt;1$$\\therefore$ $50^{99}&gt;99!$\nGENERAL下面將利用數學歸納法證明$for$ $n \\geq 2$ , $\\left({n+1}\\over{2}\\right)^n$ $&gt;$ $n!$ 成立。\nStep 1將 $n=2$ 帶入 $\\left({2+1}\\over{2}\\right)^2$ $= \\frac{9}{4}$ $&gt;$ $2!=2$。$\\therefore$ 當 $n=2$ 時，命題成立。\nStep 2Claim 當 $n=k$ 時，命題 ${(k+1)^k}\\over{2}$ $&gt;$ $k!$ 成立。\nStep 3考慮 $n=k+1$$suppose$ $\\left({(k+1)+1}\\over{2}\\right)^{k+1} &gt; (k+1)!$\n$\\left({(k+1)+1}\\over{2}\\right)^{k+1}$= $\\frac{(k+1)^{k+1} +C{k+1\\choose1}(k+1)^k+ X }{2\\times2^k}$ &gt; $\\frac{(k+1)^{k+1}+{(k+1)(k+1)^k}}{2\\times 2^k}=\\frac{(k+1)^{k+1}}{2^k}=(k+1)\\frac{(k+1)^k}{2^k}$$\\because \\frac{(k+1)^k}{2}$ $&gt;$ $k!$$\\therefore (k+1)\\frac{(k+1)^k}{2^k} &gt; (k+1)\\times k!=(k+1)!$$\\therefore \\left({(k+1)+1}\\over{2}\\right)^{k+1} &gt; (k+1)!$($X$ 是分子展開後的剩下部分，$X&gt;0$)因此藉由數學歸納法，我們證明了 $for$ $n \\geq 2$ , $\\left({n+1}\\over{2}\\right)^n$ $&gt;$ $n!$ 成立。把 $n=99$ 帶入，即可得到 $50^{99} &gt; 99!$ 。\nWe are the 21st century# I love Python,Python number one import math  print (pow(50,99)&gt;math.factorial(99));\nTrue","categories":[],"tags":["math","proof"]},{"title":"Codeforce 1536A-Omkar and Bad Story","url":"/2021/06/09/post/","content":"Codeforce 1536A-Omkar and Bad Story題目連結:https://codeforces.com/problemset/problem/1536/A題目大意:給定一個有$n$個元素的數列 &lt;$A$&gt;，求構造出一個數列 &lt;$B$&gt; 使得:(1) $B$ 的 $size\\leq300$(2) $A$ 裡的元素至少都要在 $B$ 出現一次(3) 對於所有的 $b_i,b_j$ ， $|b_i-b_j|$至少在 $B$ 出現一次$-100 \\leq A_i\\leq100$\nSolution如果 $A$ 裡面的某個元素為負數，那麼我們絕對不可能構造出數列&lt;$B$&gt;，因為加絕對值後的數必為非負整數。確定了&lt;$A$&gt;的元素都為非負整數後，那麼接著輸出 $0$ ~ $100$ 就好了，理由如下:(1) 因為 $A$ 的最大可能值為 $100$，故 $0$ ~ $100$ 必可以包含 $A$ 的元素至少一次(2) 假設 $b_i&lt;b_j$ ，那麼 $b_i\\leq |b_i-b_j|\\leq b_j$，而 $A$ 的最大值為 $100$ ，最小值為 $0$，所以 $B=[0,1,2,…,100]$必定可以包含所有的$|b_i-b_j|$\nCode#include &lt;bits/stdc++.h&gt;#define int long long#define menhera_chan_is_mine ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define pb push_back#define pi pair&lt;int, int&gt;#define BE(i) i.begin(),i.end()#define fi first#define se second#define INF 2147483647#define mkp make_pair#define ist insert#define mod 1000000009//#pragma GCC optimize(&quot;Ofast,unroll-loops,no-stack-protector,fast-math&quot;)//#pragma GCC optimize(&quot;O2&quot;)using namespace std;int min(int a, int b)&#123;return a &lt; b ? a : b;&#125;int max(int a, int b)&#123;return a &gt; b ? a : b;&#125;bool isprime(int k)&#123;bool is=1 ; for ( int i = 2 ; i*i &lt;= k ; i++ ) if ( k % i == 0 ) is = 0 ; return k&gt;1?is:0;&#125;const double PI=acos(-1);int n;int a[105];inline void sol()&#123;    cin &gt;&gt;n;    for (int i=0;i&lt;n;i++) cin &gt;&gt;a[i];    bool flg=0;    for (int i=0;i&lt;n;i++)&#123;        if (a[i]&lt;0) flg=1;    &#125;    if (flg) cout &lt;&lt;&quot;NO\\n&quot;;    else &#123;        cout &lt;&lt;&quot;YES\\n101\\n&quot;;        for (int i=0;i&lt;=100;i++)            cout &lt;&lt;i&lt;&lt;&quot; &quot;;        cout &lt;&lt;&quot;\\n&quot;;    &#125;&#125;signed main()&#123;    menhera_chan_is_mine    int _=1;    cin &gt;&gt;_;    while (_--) sol();    return 0;&#125;\n時間複雜度:$O(n)$\n","categories":[],"tags":["CF","algorithm","C++"]}]